---
layout: post
title:  "蒙皮动画算法"
date:   2017- -  23:1:38 +0800
categories: jekyll update
---

詹令   
lealzhan@126.com    
2017..   

# Contents
{:.no_toc}

* Will be replaced with the ToC, excluding the "Contents" header
{:toc}


动画技术可以看成是一种数据压缩技术，把原先非常复杂的运动，用高度优化的算法和数据进行了记录（压缩），并且可以有效重现（解压缩）。


## 矩阵变换

- 蒙皮顶点会随其绑定的节点运动，所以蒙皮顶点在其绑定的关节的局部空间内的位置在美工将蒙皮绑定后就不改变。

- 绑定姿势：binding pose， 美工将蒙皮顶点和关节进行绑定，这时蒙皮顶点在模型空间的坐标Vm,b是知道的。每个关节的局部空间坐标到模型空间坐标的变换Bi->m也是可以逐层递乘绑定姿势下的各个关节和其父关节的坐标系相对变换矩阵得到。
- 当前姿势：current pose，通过关节帧插值得到各个关节和其父关节的坐标系相对变换矩阵，需求解当前姿势的蒙皮顶点在模型空间的位置Vm,c。

- 如何解当前姿势的蒙皮顶点在模型空间的位置
	- 考虑一种简单的情况，假定每个蒙皮顶点只绑定一个关节。 
	- 先把该蒙皮顶点在绑定姿势下在模型空间下的坐标Vm,b，通过关节i局部空间坐标到模型空间坐标的变换矩阵Bi->m的逆矩阵，从模型空间变换到关节的局部空间Vlocal_i,b = Vm,b * inv(Bi->m)
	- 计算当前姿势下关节i的局部空间坐标到模型空间坐标的变换Pi->m
	- Vm,c = Vlocal_i,b * Pi->m




## 常见动画技术

常见的有 cel animation, rigid hierachical animation, per-vertex-animation, skinned animation.

### cel animation赛璐璐动画 / sprite animation 精灵动画


### rigid hierachical animation
物体由刚性物体按照一定的层次结构组成，通过控制刚性物体间的相对运动，形成动画。    
优点：运行效率高? 内存使用小？
缺点： 刚性物体间容易形成缝隙/重合等不连续的情况。   

### per-vertex-animation

每顶点动画。 每个网格定点的运动信息（pos, normal?）都记录下来。 内存使用量大。    
变种 => 变形动画 (morph target animation)=> 应用于人脸动画：预先制作很多个pose，运行时把两个或以上的pose进行融合。   
布料网格的动力学模拟:?  

### skinned animation

蒙皮动画。 本文将详细介绍。


## 蒙皮动画

### 骨架信息（Rig）

　
> 　骨骼动画通常是依赖着特定的骨架而存在的，骨架通常称为Rig，其描述了一套骨架有哪些骨骼，每根骨骼的父子关系，每根骨骼默认的Transform（也就是所谓BindPose），以及其他的一些额外信息

### 姿态（Pose）


> 一个姿态描述了一个骨架中每一个节点Transform的一个静态，诸如站立、奔跑的一帧。每个Rig都会储存一个BindPose，就是制作这个骨架时候的默认姿态（通常是T-Pose）。Pose一般不储存骨架的层次关系，而是用一个数组来依次储存每一个节点Transform，因而无法脱离Rig单独使用。另外， Pose是骨骼动画采样结果的一部分。

### 骨骼动画（Skeletal Animation）

> 一个骨骼动画描述了骨架中每一个节点Transoform随着时间改变的动态，通常使用关键帧的形式来进行储存和表达。像其他关键帧动画一样，通常具有FPS概念，即一秒钟包含多少帧。与Pose一样，骨骼动画无法脱离Rig存在，否则就无法驱动具体的对象，也无法实现蒙皮动画（因为缺乏Rig）。
> 
> 在游戏引擎中，骨骼动画通常以两个形态存在，**原始数据**和**转换后数据**：
> 
> 原始数据储存了最适合用户进行动画编辑制作的数据，比如3DMax导出的FBX格式动画，或是Unity中使用动画编辑工具制作的动画。这类数据格式简单，并且不做压缩，比如使用单独的Track来储存位移、旋转、缩放的XYZ三个通道。原始数据可以直接用于编辑和播放，但是内存开销和CPU开销通常较大，所以一般不这么做。
> 
> 转换后数据储存了对原始数据进行加工后的版本，通常在游戏引擎的导入资源阶段会进行数据转换处理。转换后的动画数据通常经过压缩，使其内存开销和CPU开销降低。转换后数据可以直接用于动画播放。

#### 骨骼动画的原始数据
> 关键帧（KeyFrame）   
> 
> 关键帧表示数据位于特定时间点的一个关键值，这个类型可以是float、Vector3之类可插值的类型。关键帧的除了包含特定时刻的数据值以外，在原始动画数据中，往往还需要包含值改变趋势——比如说斜率、切线等信息，方便在关键帧上运用Spline插值。注意关键帧与帧的区别，动画数据中只储存关键帧，其他帧都是由关键帧按时间插值的结果。
> 
> 时间轴（Track）   
> 
> 时间轴是关键帧的集合，其储存了多个关键帧的时间（对其到帧）和值，对Track在某个时间进行采样就能得到关键帧的插值结果。一条时间轴通常被用来描述完整动画的一个方面，比如某个骨骼的旋转。而在原始动画数据中，为了能够做到对动态的更精细控制，Track所表达内容往往需要更加精细，比如位置X/Y/Z三个通道分别控制。
> 
> 动画（Animation）   
> 
> 　　动画是关键帧的集合，包含了描述一整个骨骼所有部分的Track数据。动画具有长度（对其到帧）、FPS（帧率）、是否循环等属性。对动画进行采样会得到多种信息，其中最重要的就是Pose，也就是对所有Track依次采样得到的帧信息的集合。Pose可用来改变对象的Transform，或者输出到渲染器进行蒙皮渲染。


#### 骨骼动画的转换后的数据

> 原始动画数据最为精细，适用于动画编辑阶段，但内存和CPU开销较大。实际使用中，通常会对动画数据进行转换和压缩，常规的方法有这么几种：




## 整体架构


## 实现


# 参考
 
[^0]: 在C++中自己实现动画系统(一)：骨骼动画与编辑器 [`LINK`](http://www.gameres.com/478091.html)   
[^1]: 游戏引擎架构     

http://www.cnblogs.com/bite_the_bullet/archive/2011/04/28/2031941.html